<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historical Document Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Historical Fonts from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anonymous+Pro&family=Bogart&family=Cousine&family=Cutive+Mono&family=IBM+Plex+Mono&family=Libre+Baskerville&family=Oranienbaum&family=Press+Start+2P&family=Special+Elite&family=VT323&family=Tinos&family=UnifrakturMaguntia&family=Vollkorn&display=swap" rel="stylesheet">
    <!-- PDF Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Core style for the text blocks, ensuring it's black */
        .output-text { color: #000000; white-space: pre-wrap; outline: none; height: 100%; overflow: hidden;}
        
        /* Font family definitions */
        .font-vt323 { font-family: 'VT323', monospace; }
        .font-special-elite { font-family: 'Special Elite', cursive; }
        .font-cutive-mono { font-family: 'Cutive Mono', monospace; }
        .font-bogart { font-family: 'Bogart', serif; }
        .font-press-start-2p { font-family: 'Press Start 2P', cursive; }
        .font-ibm-plex-mono { font-family: 'IBM Plex Mono', monospace; }
        .font-anonymous-pro { font-family: 'Anonymous Pro', monospace; }
        .font-cousine { font-family: 'Cousine', monospace; }
        .font-libre-baskerville { font-family: 'Libre Baskerville', serif; }
        .font-oranienbaum { font-family: 'Oranienbaum', serif; }
        .font-tinos { font-family: 'Tinos', serif; }
        .font-unifrakturmaguntia { font-family: 'UnifrakturMaguntia', cursive; }
        .font-vollkorn { font-family: 'Vollkorn', serif; }

        /* Style for individual characters to allow for effects */
        .styled-char { display: inline-block; }
        
        /* Container for the document output */
        #outputContainer { background-size: 100% 100%; background-position: center; background-repeat: no-repeat; }
        
        /* Wrapper for draggable elements */
        .draggable-wrapper { position: absolute; cursor: move; border: 2px dashed transparent; transition: border-color 0.2s; }
        .draggable-wrapper:hover, .draggable-wrapper.selected { border-color: #3b82f6; }
        .draggable-wrapper.selected .resize-handle, .draggable-wrapper.selected .rotate-handle { display: block; }
        .draggable-wrapper img { width: 100%; height: 100%; pointer-events: none; user-select: none; }
        
        /* Handles for resize and rotate actions, hidden by default */
        .resize-handle, .rotate-handle { display: none; }
        .resize-handle { position: absolute; width: 12px; height: 12px; background: #3b82f6; border: 1px solid white; border-radius: 50%; bottom: -6px; right: -6px; cursor: se-resize; z-index: 10; }
        .rotate-handle { position: absolute; width: 12px; height: 12px; background: #f59e0b; border: 1px solid white; border-radius: 50%; top: -20px; left: calc(50% - 6px); cursor: grab; z-index: 10;}
        .rotate-handle::before { content: ''; position: absolute; width: 2px; height: 14px; background: #f59e0b; left: 5px; bottom: 8px; }
        
        /* Custom styling for range input thumbs */
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #4A5568; cursor: pointer; border-radius: 50%; }
    </style>
</head>
<body class="bg-gray-200 min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-5xl bg-gray-100 rounded-lg shadow-2xl p-6">
        <h1 class="text-4xl text-center text-gray-700 mb-2" style="font-family: 'Special Elite', cursive;">Historical Document Generator</h1>
        
        <!-- Controls -->
        <div class="bg-white p-4 rounded-md shadow-inner mt-4 space-y-6">
            <div>
                <h3 class="font-bold text-gray-800 text-lg">Document Style</h3>
                <label for="frameSelector" class="block text-sm font-medium text-gray-700">Background Template</label>
                <select id="frameSelector" class="control-item mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md">
                    <option value="none" selected>None (Blank)</option>
                    <option value="ovation">Ovation Invoice</option>
                    <option value="hotel">Hotel Bill</option>
                    <option value="boat">Boat Invoice</option>
                    <option value="lined">Lined Paper</option>
                    <option value="columns">Vertical Columns</option>
                </select>
            </div>
            <div id="text-controls" class="hidden border-t pt-4">
                 <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                     <div><label class="block text-sm">Font</label><select id="font-control" class="w-full"></select></div>
                     <div><label class="block text-sm">Size</label><input type="range" id="size-control" class="w-full" min="8" max="48"></div>
                     <div><label class="block text-sm">Corruption</label><input type="range" id="corruption-control" class="w-full" min="0" max="20" value="0"></div>
                 </div>
                 <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mt-4">
                     <div><label class="block text-sm">Jitter</label><input type="range" id="jitter-control" class="w-full" min="0" max="10"></div>
                     <div><label class="block text-sm">Rotation</label><input type="range" id="rotation-control" class="w-full" min="0" max="10"></div>
                     <div><label class="block text-sm">Ink Saturation</label><input type="range" id="ink-control" class="w-full" min="0" max="10" value="4"></div>
                     <div><label class="block text-sm">Blot</label><input type="range" id="blot-control" class="w-full" min="0" max="10" value="0"></div>
                 </div>
            </div>
        </div>
        
        <!-- Action Buttons -->
        <div class="flex flex-wrap justify-center items-center my-4 gap-4">
            <button id="addTextButton" class="px-6 py-3 bg-blue-600 text-white font-bold rounded-md">Add Text Block</button>
            <button id="addImageButton" class="px-6 py-3 bg-gray-600 text-white font-bold rounded-md">Add Image</button>
            <input type="file" id="imageInput" class="hidden" accept="image/*">
            <button id="saveButton" class="px-6 py-3 bg-teal-600 text-white font-bold rounded-md">Save Project</button>
            <button id="loadButton" class="px-6 py-3 bg-orange-500 text-white font-bold rounded-md">Load Project</button>
            <input type="file" id="loadInput" class="hidden" accept=".json">
            <button id="exportPdfButton" class="px-6 py-3 bg-purple-600 text-white font-bold rounded-md flex items-center">Export PDF</button>
        </div>

        <!-- Output Canvas -->
        <div id="outputContainer" class="relative mt-6 bg-white p-2 rounded-lg shadow-inner overflow-hidden min-h-[800px]">
             <div id="contentLayer" class="absolute inset-0"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Element references
            const outputContainer = document.getElementById('outputContainer');
            const contentLayer = document.getElementById('contentLayer');
            const controlsContainer = document.getElementById('text-controls');
            const frameSelector = document.getElementById('frameSelector');
            const addTextButton = document.getElementById('addTextButton');
            const addImageButton = document.getElementById('addImageButton');
            const imageInput = document.getElementById('imageInput');
            const saveButton = document.getElementById('saveButton');
            const loadButton = document.getElementById('loadButton');
            const loadInput = document.getElementById('loadInput');
            const exportPdfButton = document.getElementById('exportPdfButton');

            // Control references
            const fontControl = document.getElementById('font-control');
            const sizeControl = document.getElementById('size-control');
            const corruptionControl = document.getElementById('corruption-control');
            const jitterControl = document.getElementById('jitter-control');
            const rotationControl = document.getElementById('rotation-control');
            const inkControl = document.getElementById('ink-control');
            const blotControl = document.getElementById('blot-control');

            // State variables
            let elements = [];
            let activeElement = null;
            let action = { type: null, startX: 0, startY: 0, startW: 0, startH: 0, startRot: 0 };
            
            // Templates for document backgrounds. Stroke colors are now #000 (black).
            const templates = {
                none: 'none',
                ovation: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 800 1000'%3E%3Crect width='100%25' height='100%25' fill='white'/%3E%3Cpath stroke='%23000' stroke-width='1' d='M0 100 H 800 M0 150 H 800 M0 750 H 800 M560 0 V 100 M560 750 V 1000'/%3E%3Crect x='1' y='1' width='798' height='998' fill='none' stroke='%23000' stroke-width='2'/%3E%3C/svg%3E")`,
                hotel: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='600' height='800'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cpath stroke='%23000' stroke-width='1' d='M100 200 H 500 M 100 600 H 500 M 300 200 V 600'/%3E%3C/svg%3E")`,
                boat: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 800 1000'%3E%3Crect width='100%25' height='100%25' fill='white'/%3E%3Cg stroke='%23000' stroke-width='2'%3E%3Cpath d='M0 330 H 800 M0 380 H 800 M0 800 H 800 M560 850 H 800 M560 900 H 800 M0 950 H 800' /%3E%3Cpath d='M80 330 V 800 M560 330 V 950 M680 330 V 950' /%3E%3C/g%3E%3Crect x='1' y='1' width='798' height='998' fill='none' stroke='%23000' stroke-width='2'/%3E%3C/svg%3E")`,
                lined: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='26'%3E%3Cpath d='M0 25 H 100' stroke='%23000' stroke-width='1'/%3E%3C/svg%3E")`,
                columns: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='800' height='1000'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cpath stroke='%23000' stroke-width='1' d='M266 0 V 1000 M532 0 V 1000' /%3E%3C/svg%3E")`
            };

            const { jsPDF } = window.jspdf;

            // Function to export the current view to a PDF file
            function exportToPDF() {
                deselectAll();
                const textBlocks = document.querySelectorAll('.output-text');
                textBlocks.forEach(block => { block.style.overflow = 'visible'; });

                html2canvas(outputContainer, { scale: 2, backgroundColor: '#ffffff', useCORS: true })
                    .then(canvas => {
                        const imgData = canvas.toDataURL('image/png');
                        const pdf = new jsPDF({ orientation: 'portrait', unit: 'px', format: [canvas.width, canvas.height] });
                        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                        pdf.save("historical-document.pdf");
                        textBlocks.forEach(block => { block.style.overflow = 'hidden'; });
                    }).catch(err => {
                        console.error("Error exporting to PDF:", err);
                        textBlocks.forEach(block => { block.style.overflow = 'hidden'; });
                    });
            }

            // Creates a single styled character with various effects
            function createStyledChar(char, jitter, rotation, ink, corruption, blot) {
                const span = document.createElement('span');
                span.className = 'styled-char';
                let charToRender = char;
                if (Math.random() * 100 < corruption) {
                    const corruptedChars = ['█', '▓', '▒', '░', '#', '?', '&', '%', '$', '@'];
                    charToRender = corruptedChars[Math.floor(Math.random() * corruptedChars.length)];
                }
                span.innerHTML = (charToRender === ' ') ? '&nbsp;' : charToRender;
                
                const jitterFactor = jitter / 10.0;
                const rotationFactor = rotation / 10.0;
                
                const xOffset = (Math.random() - 0.5) * 1.5 * jitterFactor;
                const yOffset = (Math.random() - 0.5) * 1.5 * jitterFactor;
                const rot = (Math.random() - 0.5) * 2.0 * rotationFactor;
                
                // --- Ink Saturation & Blot Logic (Now Separated) ---
                const inkValue = parseInt(ink, 10);
                const blotValue = parseInt(blot, 10);

                // 1. Ink Saturation controls base opacity and faintness.
                const baseOpacity = 0.4 + (inkValue / 10.0) * 0.6;
                const opacityVariation = (1.0 - (inkValue / 10.0)) * 0.5;
                const randomFlicker = (Math.random() - 0.5) * opacityVariation;
                let finalOpacity = baseOpacity + randomFlicker;

                const faintChance = (1.0 - (inkValue / 10.0)) * 0.1;
                if (Math.random() < faintChance) {
                    finalOpacity *= 0.6;
                }

                // 2. Blot controls chance and intensity of ink blots.
                const blotChance = (blotValue / 10.0) * 0.1; // Max 10% chance
                if (Math.random() < blotChance) {
                    span.style.fontWeight = 'bold';
                    const blurAmount = (Math.random() * (blotValue / 10.0) * 0.7) + 0.2;
                    const blotOpacity = 0.5 + (Math.random() * 0.5);
                    span.style.textShadow = `0 0 ${blurAmount.toFixed(2)}px rgba(0,0,0,${blotOpacity.toFixed(2)})`;
                    finalOpacity = Math.min(1.0, finalOpacity + 0.2);
                }

                span.style.transform = `translate(${xOffset}px, ${yOffset}px) rotate(${rot}deg)`;
                span.style.opacity = Math.max(0.1, Math.min(1, finalOpacity));

                return span;
            }

            // Renders the full text of an element with all applied styles
            function renderText(elData) {
                const { el, text, font, size, jitter, rotation, ink, corruption, blot } = elData;
                const contentDiv = el.querySelector('.output-text');
                contentDiv.innerHTML = '';
                contentDiv.className = `output-text ${font}`;
                contentDiv.style.fontSize = `${size}px`;
                const lines = (text || '').replace(/\u00A0/g, ' ').split('\n');
                lines.forEach(line => {
                    const lineDiv = document.createElement('div');
                    for (const char of line) {
                        lineDiv.appendChild(createStyledChar(char, jitter, rotation, ink, corruption, blot));
                    }
                    if (line.trim() === '') lineDiv.innerHTML = '&nbsp;';
                    contentDiv.appendChild(lineDiv);
                });
            }

            // Creates a new element (text or image) and adds it to the canvas
            function createElement(type, initialData) {
                const id = initialData?.id || Date.now();
                const wrapper = document.createElement('div');
                wrapper.className = 'draggable-wrapper';
                wrapper.dataset.id = id;

                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle br';
                const rotateHandle = document.createElement('div');
                rotateHandle.className = 'rotate-handle';
                
                let elData;

                if (type === 'text') {
                    wrapper.classList.add('output-text-block');
                    const textDiv = document.createElement('div');
                    textDiv.className = 'output-text';
                    textDiv.contentEditable = "false";
                    wrapper.append(textDiv, resizeHandle, rotateHandle);
                    elData = initialData ? { ...initialData, el: wrapper } : {
                        id, el: wrapper, type: 'text', text: 'New Text Block', 
                        font: 'font-special-elite', size: 16, 
                        jitter: 5, rotation: 2, ink: 4, corruption: 0, blot: 0,
                        x: 100, y: 100, width: 300, rotation: 0
                    };
                    renderText(elData);
                } else { // type === 'image'
                    wrapper.classList.add('draggable-image-wrapper');
                    const img = document.createElement('img');
                    img.src = initialData.src;
                    wrapper.append(img, resizeHandle, rotateHandle);
                    elData = { ...initialData, id, el: wrapper };
                    if (elData.height) {
                         wrapper.style.height = `${elData.height}px`;
                    }
                }
                
                wrapper.style.left = `${elData.x}px`;
                wrapper.style.top = `${elData.y}px`;
                wrapper.style.width = `${elData.width}px`;
                wrapper.style.transform = `rotate(${elData.rotation || 0}deg)`;

                contentLayer.appendChild(wrapper);
                elements.push(elData);
                if (!initialData?.loadedFromFile) selectElement(elData);
            }
            
            // Updates the control panel based on the selected element's properties
            function updateControls() {
                if (!activeElement || activeElement.type === 'image') {
                    controlsContainer.style.display = 'none';
                    return;
                }
                
                controlsContainer.style.display = 'block';
                const { font, size, corruption, jitter, rotation, ink, blot } = activeElement;
                fontControl.innerHTML = getFontOptions(font);
                sizeControl.value = size;
                corruptionControl.value = corruption;
                jitterControl.value = jitter;
                rotationControl.value = rotation;
                inkControl.value = ink;
                blotControl.value = blot;
            }

            // Generates the HTML for the font selector dropdown
            function getFontOptions(selectedFont) {
                const fonts = { 
                    'font-special-elite': 'Classic Typewriter', 'font-cutive-mono': 'Clean Mono', 'font-bogart': 'Classic Serif', 'font-vt323': 'Dot-Matrix',
                    'font-anonymous-pro': 'Anonymous Pro', 'font-cousine': 'Courier New', 'font-ibm-plex-mono': 'IBM Plex Mono', 'font-libre-baskerville': 'Baskerville',
                    'font-oranienbaum': 'Oranienbaum', 'font-tinos': 'Tinos', 'font-unifrakturmaguntia': 'Blackletter', 'font-vollkorn': 'Vollkorn'
                };
                return Object.entries(fonts).map(([value, name]) => `<option value="${value}" ${value === selectedFont ? 'selected' : ''}>${name}</option>`).join('');
            }
            
            // Selection and deselect functions
            function selectElement(elData) {
                if (activeElement === elData) return;
                deselectAll();
                activeElement = elData;
                activeElement.el.classList.add('selected');
                updateControls();
            }

            function deselectAll() {
                if (activeElement) {
                    activeElement.el.classList.remove('selected');
                }
                activeElement = null;
                updateControls();
            }

            // --- Event Listeners ---

            // Mouse down for selecting, dragging, resizing, rotating
            document.addEventListener('mousedown', (e) => {
                const wrapper = e.target.closest('.draggable-wrapper');
                if (!wrapper) { if (!e.target.closest('#text-controls')) deselectAll(); return; }
                
                const elData = elements.find(el => el.id == wrapper.dataset.id);
                if (!elData) return;
                
                selectElement(elData);

                if (e.detail === 2 && activeElement.type === 'text') {
                    const textDiv = activeElement.el.querySelector('.output-text');
                    textDiv.contentEditable = 'true';
                    textDiv.focus();
                    const range = document.createRange();
                    range.selectNodeContents(textDiv);
                    window.getSelection().removeAllRanges();
                    window.getSelection().addRange(range);
                    
                    textDiv.addEventListener('blur', () => {
                        textDiv.contentEditable = 'false';
                        if (activeElement) {
                            activeElement.text = textDiv.innerText;
                            renderText(activeElement);
                        }
                    }, { once: true });
                    return;
                }
                
                action.startX = e.clientX;
                action.startY = e.clientY;
                action.elData = elData;
                action.startElX = elData.x;
                action.startElY = elData.y;
                action.startW = elData.el.offsetWidth;
                action.startH = elData.el.offsetHeight;

                if (e.target.classList.contains('resize-handle')) {
                    action.type = 'resize';
                } else if (e.target.classList.contains('rotate-handle')) {
                    action.type = 'rotate';
                    const rect = elData.el.getBoundingClientRect();
                    action.centerX = rect.left + rect.width / 2;
                    action.centerY = rect.top + rect.height / 2;
                    action.startRot = elData.rotation || 0;
                    action.startAngleRad = Math.atan2(e.clientY - action.centerY, e.clientX - action.centerX);
                } else {
                    action.type = 'drag';
                }
            });

            // Mouse move for active actions
            document.addEventListener('mousemove', (e) => {
                if (!action.type || !action.elData) return;
                e.preventDefault();

                const dx = e.clientX - action.startX;
                const dy = e.clientY - action.startY;
                const elData = action.elData;

                if (action.type === 'drag') {
                    elData.x = action.startElX + dx;
                    elData.y = action.startElY + dy;
                    elData.el.style.left = `${elData.x}px`;
                    elData.el.style.top = `${elData.y}px`;
                } else if (action.type === 'resize') {
                    const newWidth = Math.max(30, action.startW + dx);
                    elData.width = newWidth;
                    elData.el.style.width = `${newWidth}px`;
                    if (elData.type === 'image' && elData.aspectRatio) {
                        const newHeight = newWidth / elData.aspectRatio;
                        elData.height = newHeight;
                        elData.el.style.height = `${newHeight}px`;
                    }
                } else if (action.type === 'rotate') {
                    const currentAngle = Math.atan2(e.clientY - action.centerY, e.clientX - action.centerX);
                    const deltaAngle = currentAngle - action.startAngleRad;
                    const newRotation = action.startRot + deltaAngle * (180 / Math.PI);
                    elData.rotation = newRotation;
                    elData.el.style.transform = `rotate(${newRotation}deg)`;
                }
            });

            // Mouse up to end actions
            document.addEventListener('mouseup', () => { action.type = null; action.elData = null; });
            
            // Keydown for deleting elements
            document.addEventListener('keydown', (e) => {
                 if ((e.key === 'Delete' || e.key === 'Backspace') && activeElement) {
                     const targetIsEditable = activeElement.type === 'text' && document.activeElement === activeElement.el.querySelector('.output-text');
                     if(!targetIsEditable) {
                         e.preventDefault();
                         activeElement.el.remove();
                         elements = elements.filter(el => el.id !== activeElement.id);
                         deselectAll();
                     }
                 }
            });

            // Listeners for controls and buttons
            frameSelector.addEventListener('change', () => {
                const template = templates[frameSelector.value];
                outputContainer.style.backgroundImage = template !== 'none' ? template : '';
                if(frameSelector.value === 'lined') {
                    outputContainer.style.backgroundSize = '100% 26px';
                    outputContainer.style.backgroundRepeat = 'repeat-y';
                } else {
                    outputContainer.style.backgroundSize = '100% 100%';
                    outputContainer.style.backgroundRepeat = 'no-repeat';
                }
            });
            
            function handleControlChange(control, property) {
                if (activeElement) {
                    activeElement[property] = control.value;
                    renderText(activeElement);
                }
            }

            fontControl.addEventListener('change', () => handleControlChange(fontControl, 'font'));
            sizeControl.addEventListener('input', () => handleControlChange(sizeControl, 'size'));
            corruptionControl.addEventListener('input', () => handleControlChange(corruptionControl, 'corruption'));
            jitterControl.addEventListener('input', () => handleControlChange(jitterControl, 'jitter'));
            rotationControl.addEventListener('input', () => handleControlChange(rotationControl, 'rotation'));
            inkControl.addEventListener('input', () => handleControlChange(inkControl, 'ink'));
            blotControl.addEventListener('input', () => handleControlChange(blotControl, 'blot'));
            
            addTextButton.addEventListener('click', () => createElement('text'));
            addImageButton.addEventListener('click', () => imageInput.click());
            
            imageInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (re) => {
                        const imgSrc = re.target.result;
                        const tempImg = new Image();
                        tempImg.onload = () => {
                            const aspectRatio = tempImg.naturalWidth / tempImg.naturalHeight;
                            createElement('image', { src: imgSrc, x: 50, y: 50, width: 150, height: 150 / aspectRatio, rotation: 0, aspectRatio: aspectRatio });
                        };
                        tempImg.src = imgSrc;
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            exportPdfButton.addEventListener('click', exportToPDF);
            
            saveButton.addEventListener('click', () => {
                const saveData = {
                    template: frameSelector.value,
                    elements: elements.map(el => {
                        const { el: domEl, ...data } = el;
                        return data;
                    })
                };
                const dataStr = JSON.stringify(saveData, null, 2);
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([dataStr], {type: 'application/json'}));
                a.download = 'historical-document.json';
                a.click();
                URL.revokeObjectURL(a.href);
            });

            loadButton.addEventListener('click', () => loadInput.click());
            loadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (re) => {
                    const saveData = JSON.parse(re.target.result);
                    elements = [];
                    contentLayer.innerHTML = '';
                    frameSelector.value = saveData.template;
                    frameSelector.dispatchEvent(new Event('change'));
                    saveData.elements.forEach(elData => {
                        createElement(elData.type, {...elData, loadedFromFile: true});
                    });
                };
                reader.readAsText(file);
            });

            // Initial Load
            frameSelector.dispatchEvent(new Event('change'));
            createElement('text'); // Add an initial text block to start
        });
    </script>
</body>
</html>
