<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Historical Document Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Historical Fonts from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anonymous+Pro&family=Bogart&family=Cousine&family=Cutive+Mono&family=IBM+Plex+Mono&family=Libre+Baskerville&family=Oranienbaum&family=Press+Start+2P&family=Special+Elite&family=VT323&display=swap" rel="stylesheet">
    <!-- PDF Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        .output-text-block { position: absolute; cursor: move; padding: 5px; border: 1px dashed transparent; transition: border-color 0.2s; }
        .output-text-block:hover, .output-text-block.selected { border-color: #93c5fd; }
        .output-text { color: #2d3748; white-space: pre-wrap; outline: none; }
        
        .font-vt323 { font-family: 'VT323', monospace; }
        .font-special-elite { font-family: 'Special Elite', cursive; }
        .font-cutive-mono { font-family: 'Cutive Mono', monospace; }
        .font-bogart { font-family: 'Bogart', serif; }
        .font-press-start-2p { font-family: 'Press Start 2P', cursive; }
        .font-ibm-plex-mono { font-family: 'IBM Plex Mono', monospace; }
        .font-anonymous-pro { font-family: 'Anonymous Pro', monospace; }
        .font-cousine { font-family: 'Cousine', monospace; }
        .font-libre-baskerville { font-family: 'Libre Baskerville', serif; }
        .font-oranienbaum { font-family: 'Oranienbaum', serif; }

        .styled-char { display: inline-block; }
        
        #outputContainer { background-size: 100% 100%; background-position: center; background-repeat: no-repeat; }
        
        .draggable-image-wrapper { position: absolute; cursor: move; border: 2px dashed transparent; transition: border-color 0.2s; }
        .draggable-image-wrapper:hover, .draggable-image-wrapper.selected { border-color: #3b82f6; }
        .draggable-image-wrapper.selected .resize-handle, .draggable-image-wrapper.selected .rotate-handle,
        .output-text-block.selected .resize-handle, .output-text-block.selected .rotate-handle { display: block; }
        .draggable-image-wrapper img { width: 100%; height: 100%; pointer-events: none; }
        .resize-handle, .rotate-handle { display: none; }
        .resize-handle { position: absolute; width: 12px; height: 12px; background: #3b82f6; border: 1px solid white; border-radius: 50%; bottom: -6px; right: -6px; cursor: se-resize; }
        .rotate-handle { position: absolute; width: 12px; height: 12px; background: #f59e0b; border: 1px solid white; border-radius: 50%; top: -20px; left: calc(50% - 6px); cursor: grab; }
        .rotate-handle::before { content: ''; position: absolute; width: 2px; height: 14px; background: #f59e0b; left: 5px; bottom: 8px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #4A5568; cursor: pointer; border-radius: 50%; }
    </style>
</head>
<body class="bg-gray-200 min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-5xl bg-gray-100 rounded-lg shadow-2xl p-6">
        <h1 class="text-4xl text-center text-gray-700 mb-2" style="font-family: 'Special Elite', cursive;">Historical Document Generator</h1>
        
        <!-- Controls -->
        <div class="bg-white p-4 rounded-md shadow-inner mt-4 space-y-6">
            <div><h3 class="font-bold text-gray-800 text-lg">Document Style</h3><label for="frameSelector" class="block text-sm font-medium text-gray-700">Background Template</label><select id="frameSelector" class="control-item mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md"><option value="none" selected>None (Blank)</option><option value="ovation">Ovation Invoice</option><option value="hotel">Hotel Bill</option><option value="lined">Lined Paper</option><option value="columns">Vertical Columns</option></select></div>
            <div id="text-controls" class="hidden border-t pt-4">
                 <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div><label class="block text-sm">Font</label><select id="font-control" class="w-full"></select></div>
                    <div><label class="block text-sm">Size</label><input type="range" id="size-control" class="w-full" min="8" max="48"></div>
                    <div><label class="block text-sm">Corruption</label><input type="range" id="corruption-control" class="w-full" min="0" max="20" value="0"></div>
                 </div>
                 <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
                    <div><label class="block text-sm">Jitter</label><input type="range" id="jitter-control" class="w-full" min="0" max="10"></div>
                    <div><label class="block text-sm">Rotation</label><input type="range" id="rotation-control" class="w-full" min="0" max="10"></div>
                    <div><label class="block text-sm">Ink Variation</label><input type="range" id="ink-control" class="w-full" min="0" max="10"></div>
                 </div>
            </div>
        </div>
        
        <!-- Action Buttons -->
        <div class="flex flex-wrap justify-center items-center my-4 gap-4">
            <button id="addTextButton" class="px-6 py-3 bg-blue-600 text-white font-bold rounded-md">Add Text Block</button>
            <button id="addImageButton" class="px-6 py-3 bg-gray-600 text-white font-bold rounded-md">Add Image</button>
            <input type="file" id="imageInput" class="hidden" accept="image/*">
            <button id="exportPdfButton" class="px-6 py-3 bg-purple-600 text-white font-bold rounded-md flex items-center">Export PDF</button>
        </div>

        <!-- Output Canvas -->
        <div id="outputContainer" class="relative mt-6 bg-white p-2 rounded-lg shadow-inner overflow-hidden min-h-[800px]">
             <div id="contentLayer" class="absolute inset-0"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const outputContainer = document.getElementById('outputContainer');
            const contentLayer = document.getElementById('contentLayer');
            const controlsContainer = document.getElementById('text-controls');
            const frameSelector = document.getElementById('frameSelector');
            const addTextButton = document.getElementById('addTextButton');
            const addImageButton = document.getElementById('addImageButton');
            const imageInput = document.getElementById('imageInput');
            const exportPdfButton = document.getElementById('exportPdfButton');

            // Control elements
            const fontControl = document.getElementById('font-control');
            const sizeControl = document.getElementById('size-control');
            const corruptionControl = document.getElementById('corruption-control');
            const jitterControl = document.getElementById('jitter-control');
            const rotationControl = document.getElementById('rotation-control');
            const inkControl = document.getElementById('ink-control');

            let elements = [];
            let activeElement = null;
            let action = { type: null, startX: 0, startY: 0, startW: 0, startH: 0, startRot: 0 };
            
            const templates = {
                none: 'none',
                ovation: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='800' height='1000'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cpath stroke='%23cccccc' stroke-width='1' fill='none' d='M0 100 H 800 M0 150 H 800 M0 750 H 800 M560 0 V 100 M560 750 V 1000'/%3E%3Cpath stroke='%23cccccc' stroke-width='2' fill='none' d='M1 1 H 799 V 999 H 1 Z'/%3E%3C/svg%3E")`,
                hotel: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='600' height='800'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cpath stroke='%23333' stroke-width='1' d='M100 200 H 500 M 100 600 H 500 M 300 200 V 600'/%3E%3C/svg%3E")`,
                lined: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='26'%3E%3Cpath d='M0 25 H 100' stroke='%23e2e8f0' stroke-width='1'/%3E%3C/svg%3E")`,
                columns: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='800' height='1000'%3E%3Crect x='0' y='0' width='100%25' height='100%25' fill='white'/%3E%3Cpath stroke='%23e5e7eb' stroke-width='1' d='M266 0 V 1000 M532 0 V 1000' /%3E%3C/svg%3E")`
            };

            const { jsPDF } = window.jspdf;

            function exportToPDF() {
                deselectAll();
                html2canvas(outputContainer, { scale: 2, backgroundColor: '#ffffff', useCORS: true }).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    const pdf = new jsPDF({ orientation: 'portrait', unit: 'px', format: [canvas.width, canvas.height] });
                    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                    pdf.save("historical-document.pdf");
                }).catch(err => console.error("Error exporting to PDF:", err));
            }

            function createStyledChar(char, jitter, rotation, ink, corruption) {
                const span = document.createElement('span');
                span.className = 'styled-char';

                let charToRender = char;
                const corruptionChance = corruption; // Slider value is direct percentage
                if (Math.random() * 100 < corruptionChance) {
                    const corruptedChars = ['█', '▓', '▒', '░', '#', '?', '&', '%', '$', '@'];
                    charToRender = corruptedChars[Math.floor(Math.random() * corruptedChars.length)];
                }

                span.innerHTML = (charToRender === ' ') ? '&nbsp;' : charToRender;
                
                const jitterFactor = jitter / 10.0;
                const rotationFactor = rotation / 10.0;
                const inkFactor = ink / 10.0;
                
                const xOffset = (Math.random() - 0.5) * 1.5 * jitterFactor;
                const yOffset = (Math.random() - 0.5) * 1.5 * jitterFactor;
                const rot = (Math.random() - 0.5) * 2.0 * rotationFactor;
                const opacity = 1 - (Math.random() * 0.4 * inkFactor);
                
                span.style.transform = `translate(${xOffset}px, ${yOffset}px) rotate(${rot}deg)`;
                span.style.opacity = opacity;
                return span;
            }

            function renderText(elData) {
                const { el, text, font, size, jitter, rotation, ink, corruption } = elData;
                const contentDiv = el.querySelector('.output-text');
                contentDiv.innerHTML = '';
                contentDiv.className = `output-text ${font}`;
                contentDiv.style.fontSize = `${size}px`;
                const lines = text.replace(/\u00A0/g, ' ').split('\n');
                lines.forEach(line => {
                    const lineDiv = document.createElement('div');
                    for (const char of line) {
                        lineDiv.appendChild(createStyledChar(char, jitter, rotation, ink, corruption));
                    }
                    if (line.trim() === '') lineDiv.innerHTML = '&nbsp;';
                    contentDiv.appendChild(lineDiv);
                });
            }

            function createTextBlock() {
                const id = Date.now();
                const wrapper = document.createElement('div');
                wrapper.className = 'output-text-block';
                wrapper.dataset.id = id;
                wrapper.style.left = '100px';
                wrapper.style.top = '100px';
                wrapper.style.width = '300px';
                wrapper.style.transform = 'rotate(0deg)';

                const textDiv = document.createElement('div');
                textDiv.className = 'output-text';
                textDiv.contentEditable = "false";
                
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle br';
                const rotateHandle = document.createElement('div');
                rotateHandle.className = 'rotate-handle';

                wrapper.append(textDiv, resizeHandle, rotateHandle);

                contentLayer.appendChild(wrapper);
                const elData = {
                    id, el: wrapper, type: 'text', text: 'New Text Block', 
                    font: 'font-special-elite', size: 16, 
                    jitter: 5, rotation: 2, ink: 4, corruption: 0,
                    x: 100, y: 100, width: 300, rotation: 0
                };
                elements.push(elData);
                renderText(elData);
                selectElement(elData);
            }

            function createImageElement(src) {
                const id = Date.now();
                const wrapper = document.createElement('div');
                wrapper.className = 'draggable-image-wrapper';
                wrapper.dataset.id = id;
                wrapper.style.left = '50px';
                wrapper.style.top = '50px';
                wrapper.style.width = '150px';
                wrapper.style.transform = 'rotate(0deg)';
                const img = document.createElement('img');
                img.src = src;
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle br';
                const rotateHandle = document.createElement('div');
                rotateHandle.className = 'rotate-handle';
                wrapper.append(img, resizeHandle, rotateHandle);
                contentLayer.appendChild(wrapper);
                const elData = { id, el: wrapper, type: 'image', src, x: 50, y: 50, width: 150, rotation: 0 };
                elements.push(elData);
                selectElement(elData);
            }
            
            function updateControls() {
                if (!activeElement || activeElement.type !== 'text') {
                    controlsContainer.style.display = 'none';
                    return;
                }
                
                controlsContainer.style.display = 'grid';
                const { font, size, corruption, jitter, rotation, ink } = activeElement;
                fontControl.innerHTML = getFontOptions(font);
                sizeControl.value = size;
                corruptionControl.value = corruption;
                jitterControl.value = jitter;
                rotationControl.value = rotation;
                inkControl.value = ink;
            }

            function getFontOptions(selectedFont) {
                const fonts = { 'font-special-elite': 'Classic Typewriter', 'font-cutive-mono': 'Clean Mono', 'font-bogart': 'Classic Serif', 'font-vt323': 'Dot-Matrix' };
                return Object.entries(fonts).map(([value, name]) => `<option value="${value}" ${value === selectedFont ? 'selected' : ''}>${name}</option>`).join('');
            }
            
            function selectElement(elData) {
                if (activeElement === elData) return;
                deselectAll();
                activeElement = elData;
                activeElement.el.classList.add('selected');
                updateControls();
            }

            function deselectAll() {
                if (activeElement) {
                    activeElement.el.classList.remove('selected');
                }
                activeElement = null;
                updateControls();
            }

            document.addEventListener('mousedown', (e) => {
                const wrapper = e.target.closest('.output-text-block, .draggable-image-wrapper');
                
                if (!wrapper) {
                    if (!e.target.closest('#text-controls')) deselectAll();
                    return;
                }
                
                const elData = elements.find(el => el.id == wrapper.dataset.id);
                if (!elData) return;

                selectElement(elData);

                if (e.detail === 2 && activeElement.type === 'text') {
                    const textDiv = activeElement.el.querySelector('.output-text');
                    textDiv.contentEditable = 'true';
                    textDiv.focus();
                    const range = document.createRange();
                    range.selectNodeContents(textDiv);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                    
                    const elementBeingEdited = activeElement;
                    textDiv.addEventListener('blur', () => {
                        textDiv.contentEditable = 'false';
                        if (elementBeingEdited) {
                            elementBeingEdited.text = textDiv.innerText;
                            renderText(elementBeingEdited);
                        }
                    }, { once: true });
                    return;
                }
                
                const rect = wrapper.getBoundingClientRect();
                action.startX = e.clientX;
                action.startY = e.clientY;
                action.elData = activeElement;

                if (e.target.classList.contains('resize-handle')) {
                    action.type = 'resize';
                    action.startW = rect.width;
                } else if (e.target.classList.contains('rotate-handle')) {
                    action.type = 'rotate';
                    action.centerX = wrapper.offsetLeft + rect.width / 2;
                    action.centerY = wrapper.offsetTop + rect.height / 2;
                } else {
                    action.type = 'drag';
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!action.type || !action.elData) return;
                e.preventDefault();
                const dx = e.clientX - action.startX;
                const dy = e.clientY - action.startY;
                if (action.type === 'drag') {
                    action.elData.x += dx;
                    action.elData.y += dy;
                    action.elData.el.style.left = `${action.elData.x}px`;
                    action.elData.el.style.top = `${action.elData.y}px`;
                    action.startX = e.clientX;
                    action.startY = e.clientY;
                } else if (action.type === 'resize') {
                    action.elData.width = Math.max(30, action.startW + dx);
                    action.elData.el.style.width = `${action.elData.width}px`;
                } else if (action.type === 'rotate') {
                    const angle = Math.atan2(e.clientY - (outputContainer.offsetTop + action.centerY), e.clientX - (outputContainer.offsetLeft + action.centerX)) * (180 / Math.PI) + 90;
                    action.elData.rotation = angle;
                    action.elData.el.style.transform = `rotate(${angle}deg)`;
                }
            });

            document.addEventListener('mouseup', () => { action.type = null; action.elData = null; });
            
            document.addEventListener('keydown', (e) => {
                 if ((e.key === 'Delete' || e.key === 'Backspace') && activeElement) {
                     const targetIsEditable = activeElement.type === 'text' && document.activeElement === activeElement.el.querySelector('.output-text');
                     if(!targetIsEditable) {
                        e.preventDefault();
                        activeElement.el.remove();
                        elements = elements.filter(el => el.id !== activeElement.id);
                        deselectAll();
                     }
                }
            });

            frameSelector.addEventListener('change', () => {
                const template = templates[frameSelector.value];
                outputContainer.style.backgroundImage = template !== 'none' ? template : '';
                if(frameSelector.value === 'lined') outputContainer.style.backgroundSize = '100% 1.6em';
                else outputContainer.style.backgroundSize = '100% 100%';
            });
            
            fontControl.addEventListener('change', (e) => { if(activeElement) { activeElement.font = e.target.value; renderText(activeElement); }});
            sizeControl.addEventListener('input', (e) => { if(activeElement) { activeElement.size = e.target.value; renderText(activeElement); }});
            corruptionControl.addEventListener('input', (e) => { if(activeElement) { activeElement.corruption = e.target.value; renderText(activeElement); }});
            jitterControl.addEventListener('input', (e) => { if(activeElement) { activeElement.jitter = e.target.value; renderText(activeElement); }});
            rotationControl.addEventListener('input', (e) => { if(activeElement) { activeElement.rotation = e.target.value; renderText(activeElement); }});
            inkControl.addEventListener('input', (e) => { if(activeElement) { activeElement.ink = e.target.value; renderText(activeElement); }});
            
            addTextButton.addEventListener('click', createTextBlock);
            addImageButton.addEventListener('click', () => imageInput.click());
            imageInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = (re) => createImageElement(re.target.result);
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
            exportPdfButton.addEventListener('click', exportToPDF);
            
            // Initial Load
            frameSelector.dispatchEvent(new Event('change'));
        });
    </script>
</body>
</html>
